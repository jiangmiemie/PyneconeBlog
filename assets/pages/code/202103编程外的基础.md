# General Knowledge


常识涵盖编程学习过程中可能遇到的知识，如YAML、Markdown等。


## Markup language


### Markdown


Markdown 是一种轻量级标记语言，可用于将格式元素添加到纯文本文档。 Markdown 由 John Gruber 于 2004 年创建，现在是世界上最流行的标记语言之一。


#### How to learn Markdown


Markdown 语法丰富，但大部分不完整，缺乏有效的长期示例。 所以选择教程的关键是开源时间长。


[markdowntutorial](https://www.markdowntutorial.com/)


### YAML


YAML Ain't Markup Language（但它确实看起来像）github/docker 和其他程序员工具被广泛使用。


#### How to learn YAML


YAML很简单，还在更新中，查看最新的官方文档即可:[yaml](https://yaml.org/)


## Terminal



Terminals, 也称为命令行或控制台，使我们能够在我们的计算机上完成和自动化任务，而无需图形用户界面。 终端起源于 1950 年代到 1960 年代左右，从那时起，它一直是所有操作系统的一个不变特征——从台式机到隐藏在云中的服务器，再到像 Raspberry PI Zero 这样的微型计算机，甚至手机。 在大多数情况下，终端、命令行意味着同一件事。


### How to learn Terminal


现在有很多不同的设备，它们对应的Terminal命令也不同。 而且终端命令往往直接单词缩写是猜不出来的，所以在学习终端命令教程的时候需要注意：


- 足够完整
- 使用示例


[tldr](https://tldr.inbrowser.app/)是社区维护的命令行工具帮助页面合集，支持在线查询终端命令，有不同平台选择，支持不同语言显示


## Web Security Knowledge


### SSL/TLS


SSL/TLS是一种密码通信框架，是世界上使用最广泛的密码通信方式。 SSL/TLS是对称密码、消息认证码、公钥密码、数字签名、伪随机数发生器等技术的结合，堪称密码学的杰作。


SSL/TLS 是一个安全的通信框架，可以承载 HTTP 协议或 SMTP/POP3 协议等。


SSL（Secure Socket Layer）是 Netscape 于 1994 年设计并于 1995 年发布的 3.0 版协议。


TLS（Transport Layer Security）是IETF基于SSL 3.0设计的协议，实际上相当于SSL的后续版本。


TLS主要分为两层，最底层是TLS记录协议，主要负责使用对称密码对消息进行加密。


上层是TLS握手协议，主要分为4个部分：握手协议、密码规范变更协议和应用数据协议。


- 握手协议负责就客户端和服务器之间的密码算法和共享密钥达成一致，包括证书认证，是四个协议中最复杂的。
- 密码规范更改协议负责向通信方发送密码更改信号
- 警告协议负责在发生错误时将错误信息传达给对方
- 应用数据协议负责将TLS携带的应用数据传送给通信方。


## Interview frequently asked


### TCP connection and closing process


#### Three waves and the reason


在TCP/IP协议中，TCP协议提供可靠的连接服务，使用三次握手建立连接


##### First handshake


(a) 建立连接时，客户端向服务器发送一个syn包（syn=j），并进入SYN_SEND状态，等待服务器确认；


SYN：同步序列号（Synchronize Sequence Numbers）。 它是TCP/IP建立连接时使用的握手信号。 当客户端和服务器之间建立正常的TCP网络连接时，客户端首先发送一个SYN报文，服务器响应一个SYN+ACK表示已经收到消息，最后客户端响应一个ACK报文。


这样就可以在客户端和服务器之间建立可靠的TCP连接，并在客户端和服务器之间传递数据。


##### Second handshake


服务器收到一个 SYN 包，必须确认客户端的 SYN（ack=j+1），同时自己发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；


ACK（Acknowledge character）是确认字符，是数据通信中接收站向发送站发送的传输类控制字符。 表示发送的数据已经正确接收。


在TCP/IP协议中，如果接收方成功接收到数据，它会回复一个ACK数据。 通常ACK信号有自己固定的格式、长度和大小，由接收方回复给发送方。


##### Third handshake


客户端收到服务器发来的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送后，客户端和服务器进入ESTABLISHED状态，完成三次握手。


第三次握手是为了防止失败的连接请求报文段突然又传给服务器，从而产生错误。


例如，如果请求是在这样一种情况下发起的：客户端发送的第一个连接请求在网络节点中由于某种原因延迟，直到某个时间点释放连接才到达服务器，这 是一条久违的消息，但是服务器仍然认为这是客户端连接请求的第一次握手，所以服务器以第二次握手响应客户端。


如果只有两次握手，那么至此，连接已经建立，但是此时客户端还没有任何数据可以发送，服务器还在傻傻的等待好消息，造成了资源的极大浪费。 所以需要第三次握手，只有客户端再次响应才能避免这种情况。


#### Four handshakes and the reason


##### First handshake


Client发送一个FIN，用于关闭Client到Server的数据传输，Client进入FIN_WAIT_1状态。


##### Second wave


Server收到一个FIN，发送ACK给Client，确认收到的序号+1（同SYN，一个FIN占用一个序号），Server进入CLOSE_WAIT状态


##### Third wave


Server发送一个FIN，用于关闭Server到Client的数据传输，Server进入LAST_ACK状态


##### The fourth wave


Client收到FIN，Client进入TIME_WAIT状态，然后向Server发送ACK，收到确认号+1，Server进入CLOSED状态，完成四次挥手。


所谓四次挥手就是终止TCP连接，也就是断开一个TCP连接，客户端和服务端一共需要交互四次。 该过程由执行 CLOSED 的客户端或服务器触发。


由于 TCP 连接是全双工的，每个方向都必须单独关闭。 原理是当一方发送完数据后，发送一个FIN终止该方向的连接。 首先执行关机的一方将执行主动关机，而另一方将执行被动关机。


在四波时，发起关闭的一方将进入 TIME_WAIT 状态，并且该状态将保持两倍最大段生命周期 (2MSL)。


为什么我们不直接关闭，进入等待状态呢？


1、保证client发送的ACK报文段能够到达server，从而保证tcp连接能够可靠的关闭。


这个很好理解，如果client关闭后立即发起ACK，那么如果ACK丢了，server会一直处于等待关闭确认的状态，然后超时后发送关闭请求，client 此时已经关闭，则服务器无法正常关闭。


2.保证本次连接的数据段消失，防止无效数据段。


client发送ACK后，等待2MSL，使本次连接产生的数据段从网络中消失，从而保证关闭连接后不会再有数据段还徘徊在网络中骚扰server；


还有一点，如果客户端重新发送请求，如果之前连接的一些数据还在网络中徘徊，这些延迟的数据只有在新连接建立后才能到达Server，而由于新连接的端口号和 old connection是一样的，由于TCP协议是根据socket pair来判断不同的连接，所以TCP协议认为延迟的数据是属于新连接的，与真正的新连接的数据包相混淆。


为什么是2MSL？


我们知道服务器收到一个ACK并关闭连接。 但是client没有办法知道ACK有没有到达server，所以就开始等待了？ 等什么？ 如果ACK没有到达服务器，服务器会超时重传超时重传FIN报文，那么如果客户端等待足够长的时间收到FIN报文，就说明ACK没有到达服务器，所以发送ACK 直到没有足够的时间收到FIN，说明ACK已经成功到达。 这个等待时间至少为：服务器的超时时间+FIN发送时间，为了保证可靠性，使用了比较保守的等待时间2MSL。


MSL，Maximum Segment Life，是TCP Segment生存时间的TCP限制。


客户端发送ACK，等待ACK到达超时时间MSL的对方，等待FIN超时重传，也是MSL，所以如果在2MSL时间内没有收到FIN，说明对方安全 收到 FIN。


### What is the difference between HTTP and HTTPS?


- Does HTTPS use symmetric or asymmetric encryption?

HTTPS uses symmetric encryption for the encryption of content transfer, and asymmetric encryption for the certificate validation phase.

- Briefly describe the encryption process of HTTPS, how many communications are required?


① Certificate validation phase:

1) The browser initiates an HTTPS request;

2) The server side returns the HTTPS certificate;

3) The client verifies whether the certificate is legal or not, and prompts an alarm if it is not legal.

② Data transmission stage:

1) Generate random numbers locally when the certificate is verified as legal;

2) Encrypt the random numbers by public key and transmit the encrypted random numbers to the server side;

3) Decrypting the random numbers by the private key at the server side;

4) The server constructs a symmetric encryption algorithm through the random number passed in by the client, encrypts the returned result content and transmits it.


### What is the difference between cookie and session?


A cookie is the authentication information that exists locally, and a session is the authentication information that exists on the server.

- Advantages of cookies and JWT

The cookie structure is simple and persistent and does not consume server resources

JSON Web Token consists of three parts, which are connected by a dot (.) The three parts are These three parts are: Header, Payload, Signature, which can store some non-sensitive information necessary for other business logic in itself.


### What is same-origin policy and how is CORS implemented?


Two URLs are homologous if they have the same protocol, port (en-US) (if specified), and host.

The Cross-Origin Resource Sharing standard adds a set of HTTP prefix fields that allow the server to declare which source sites have access to which resources through the browser.


### Why MD5 cannot be used to store passwords


#### Why Encryption


Many software engineers believe that MD5 is an encryption algorithm, but this is a very wrong and dangerous view. "encryption'.

Similar to the question "Why can't we use MD5 to store passwords? is similar to the question "Why can't we store passwords in plaintext? storing passwords in plaintext is a seemingly infeasible solution unless we can guarantee 100% that the password fields in the database are not accessible to anyone, including not only potential attackers, but also system developers and administrators.

However, this is a very ideal situation, in a real production environment, we can not defend against all attacks from hackers, or even completely block access to developers and administrators, because we always need to trust and authorize some people or programs to have all access rights to the current database, which also leaves the attackers can exploit the vulnerability, we can not be comprehensive in defending against external attacks We can only increase the cost to the attacker as much as possible, which is the reason for using MD5 or other ways to store passwords.


#### Why you should stop using MD5 encryption


Many developers have a great misunderstanding of the role and definition of MD5. MD5 is not an encryption algorithm, but a digest algorithm, which we can also call a hash function that maps all keys in an infinite key-value space evenly to a key-value space of a specified size; a good digest algorithm can help us ensure the integrity of the file and avoid malicious tampering by attackers. tampering, but the function of an encryption algorithm or encryption is - to encode a message or information in some specific way that only authorized parties can access the original data, while those who are not authorized cannot access the original text from the ciphertext.

Since encryption needs to guarantee both the secrecy and integrity of the message, the encryption process uses a series of algorithms. MD5 can indeed be used as a hash function in the encryption process to guarantee the integrity of the message, but we also need another algorithm to guarantee the secrecy of the message, so since the information hashed by MD5 cannot be restored, relying on MD5 alone cannot complete the encryption.

In any scenario, we should avoid the use of MD5 and can choose a better digest algorithm instead of MD5, such as SHA256, SHA512.

After talking about so many misunderstandings about MD5, let's go back to the topic at the beginning of the day, "Why MD5 can't be used to store passwords", for which there is a simplest answer, that is, MD5 is not secure enough. When the entire database in the system is compromised by an attacker, storing a summary of passwords instead of plaintext is the greatest protection we can provide to all users. It is important to know that it is not only MD5 that is not secure enough, but any digest algorithm is not secure enough in the scenario of storing passwords, and we will hash the function in this article 'Why Hash Functions Cannot Be Used to Store Passwords' and other related mechanisms for security.


#### Comparative Analysis


Now that we have some brief understanding of hash functions and cryptographic algorithms, this next section analyzes the security of storing passwords using several different methods:

- Storing passwords using hashes;
- Storing passwords using hashes with salt;
- storing passwords using cryptographic algorithms;
- storing passwords using bcrypt;

Some simple cryptographic knowledge may be involved in the analysis, and some events in the history of cryptography will be touched upon, but this will not pose much of an obstacle to understanding the security of the different methods.


##### Hashing


Today, if we use hashes to store passwords directly, it is not much different from storing plaintexts, all attackers today have mastered the rainbow table as a tool, we can understand the rainbow table as a large precomputed table, which stores the hashes of some common passwords, when the attacker gets the database of some websites by hacking, he can use the mapping stored in the precomputed table to find the original password.

The attacker only needs to calculate some hashes of some common passwords in advance to find many of the passwords used for storage in the database, Wikipedia has a list of the most common passwords, in 2016 statistics found that the top 25 most used passwords accounted for 10% of the total number of surveys, although this does not exclude the inaccuracy of the statistics itself, but also enough to show that just using the hash is not enough to store passwords. hash is not secure enough to store passwords.


##### Hash salting


In the 1970s and 1980s, early versions of Unix systems stored salted hashed passwords in /etc/passwrd, and the salted hashes and salts were stored together in the /etc/passwd file. may lie in the generation and selection of the salt: the

md5(salt, password), salt
The main reason for adding salt is to increase the computational cost of the attacker, when the attacker successfully gets the data in the database, because each password is hashed using a random salt, so the pre-computed rainbow table is no way to immediately decipher the original data before the hash, the attacker needs to calculate each hash separately, which can increase the cost of the attacker and reduce the possibility of the original password being deciphered on a large scale. The possibility of a wide range of deciphering.

In this case, the cost for the attacker to crack a user's password is actually equal to the probability of finding a hash collision, because the attacker does not actually need to know what the user's password is, he only needs to find a value value, and this value salted hash is exactly the same as the password salted hash to log into the user's account

```language
hash(salt, value) = hash(salt, password)
```

This situation is called a hash collision in cryptography, which means that two different values correspond to the same hash. The probability of a hash function or digest algorithm being found to have a hash collision determines the security of the algorithm, which was discovered decades ago in the design of MD5 and in subsequent developments we found a way to quickly create hash collisions at low cost.

```language
1996 The Status of MD5 After a Recent Attack - a flaw in the design of MD5 was discovered, but it was not considered fatal and cryptographers began to recommend alternative digest algorithms;
2004 How to Break MD5 and Other Hash Functions -- it was discovered that the MD5 digest algorithm was not resistant to hash collisions and that we could not use MD5 algorithms in the digital security space;
2006 A Study of the MD5 Attacks: Insights and Improvements -- creating a set of files with identical MD5 digests;
2008 MD5 considered harmful today -- creating forged SSL certificates;
2010 MD5 vulnerable to collision attacks -- CMU Software Engineering Institute considers the MD5 digest algorithm to be cryptographically broken and unsuitable for use.
2012 Flame -- malware exploits MD5 vulnerabilities and forges Microsoft digital signatures;
```

From past history, we should not use MD5 salting to store users' passwords in order to secure their sensitive information, so can we use a more secure digest algorithm? No, the hash function is not specifically designed to store user passwords, so its computation may still be relatively fast, and attackers today can perform hundreds of millions of computations per second to crack user passwords through GPUs, so we cannot use this way to store user passwords, interested readers can learn about Hashcat, a tool used to recover passwords.

##### Encryption

Since today's hardware can quickly help an attacker crack a user's password, can we store passwords in other ways instead of hash functions? Some engineers have thought of using encryption algorithms instead of hash functions, which can avoid hash collisions at source. This approach looks very nice, but has a fatal drawback, which is how we store the secret key used to encrypt passwords.

Since the repository where the passwords are stored can be compromised, the service used to store the secret key can also be attacked. We can never guarantee that our database and server are secure, and once the secret key is obtained by an attacker, they can easily recover the user's password, because the process of verifying the user's password requires decrypting the password in memory, and then the password in plaintext may be exposed in memory. There is still a risk that the user's password will be compromised.

The use of encryption to store passwords is more likely to lead to password leaks and security incidents in companies and websites with poor security awareness and capabilities than hashing with salt.

##### bcrypt

Hash and salt does increase the cost for attackers, but today it is not enough, we need a more secure way to store the user's password, which is widely used today bcrypt, using bcrypt is a more secure way than directly using hash and salt, and is the method we currently recommend to use, in order to increase the cost for attackers, the bcrypt introduces an adjustable parameter of computational cost that can adjust the cost of executing the bcrypt function.

When we increase the cost of verifying a user's password by several orders of magnitude, the cost to the attacker actually increases by several orders of magnitude. As long as we make the attacker's cost of attack greater than the hardware limit, and keep the normal request time within a reasonable range, we can ensure the relative security of the user's password.

The bcrypt algorithm is specifically designed for hashed passwords, so it is a relatively slow execution algorithm, which can reduce the number of passwords an attacker can process per second, thus avoiding dictionary attacks by attackers.

```Go
# Go
func main() {
	for cost := 10; cost <= 15; cost++ {
		startedAt := time.Now()
		bcrypt.GenerateFromPassword([]byte("password"), cost)
		duration := time.Since(startedAt)
		fmt.Printf("cost: %d, duration: %v\n", cost, duration)
	}
}

$ go run bcrypt.go
cost: 10, duration: 51.483401ms
cost: 11, duration: 100.639251ms
cost: 12, duration: 202.788492ms
cost: 13, duration: 399.552731ms
cost: 14, duration: 801.041128ms
cost: 15, duration: 1.579692689s
```

The relationship between cost and running time can be seen when running the above code snippet. For every +1 cost of running the algorithm, the final time taken by the current algorithm doubles, which is related to the implementation principle of the bcrypt algorithm.

If the development of hardware allows an attacker to attack passwords stored using bcrypt, we can simply increase the cost parameter of the bcrypt algorithm to increase the cost to the attacker, which is the subtlety of the bcrypt design, so using bcrypt is a more secure way to store user passwords.

When the database is accessed by an attacker, how can we ensure that the user's password is difficult to be "deciphered" by the attacker, as a last resort to protect the user's confidential information, it is important to choose a secure and appropriate method. The ability of an attacker to break a user's password generally depends on two conditions:

- Whether the encryption algorithm used is secure enough, the time cost of using brute force is extremely high;
- Good enough hardware support to support large-scale, high-speed hash computation;

The way to defend against an attacker is actually to increase the cost of a single algorithm run. When we increase the user's authentication elapsed time from 0.1ms to 500ms, the attacker's computational cost increases by a factor of 5000, a result that passwords that previously took hours to crack now take years.

No matter what, using MD5, MD5 salted or other hashing methods to store passwords is not secure, and we hope that engineers can avoid using MD5 in such scenarios, and in other scenarios where hash functions must be used, it is also recommended to use other algorithms instead, such as SHA-512, etc.

Of course, how to ensure the security of confidential user information is not just a cryptographic problem, it is also an engineering problem, any oversight of engineering developers may lead to security incidents, so we as developers should also be careful and fearful when dealing with sensitive information. At the end of the day, let's look at some of the more open and relevant issues, and interested readers can think carefully about the following questions:

- How many MD5 hashes (orders of magnitude) can be computed per second using a GPU? How long is it possible to crack a password stored using MD5 salting?
- Assuming that it takes 500ms to compute a hash, how long does it take to crack a hash generated by the bcrypt algorithm?
- MD5 hash 23cdc18507b52418db7740cbb5543e54 The corresponding original text might be? Tell us about the tools you used and the process of deciphering.
